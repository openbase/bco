package org.openbase.bco.app.openapiserver;

/*-
 * #%L
 * BCO OpenAPI Server
 * %%
 * Copyright (C) 2018 - 2019 openbase.org
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * #L%
 */

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.Message;
import com.google.protobuf.ProtocolMessageEnum;
import com.googlecode.protobuf.format.JsonFormat;
import org.openbase.bco.registry.remote.Registries;
import org.openbase.jul.exception.CouldNotPerformException;
import org.openbase.jul.exception.printer.ExceptionPrinter;
import org.openbase.jul.exception.printer.LogLevel;
import org.slf4j.Logger;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class RegistryRPCProcessor {

    static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);
    static final JsonFormat JSON_FORMAT = new JsonFormat();

    public static <T> ResponseEntity<T> invokeMethodOrFailWithBadRequest(final Object parameter, final Class<T> returnClass, final Logger logger) {
        try {
            return ResponseEntity.ok(invokeMethod(parameter, returnClass, 3));
        } catch (CouldNotPerformException ex) {
            ExceptionPrinter.printHistory(ex, logger, LogLevel.DEBUG);
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }
    }

    public static <T> T invokeMethod(final Object parameter, final Class<T> returnClass) throws CouldNotPerformException {
        return invokeMethod(parameter, returnClass, 3);
    }

    private static <T> T invokeMethod(final Object parameter, final Class<T> returnClass, final int stackTraceMethodIndex) throws CouldNotPerformException {
        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
        String methodName = stackTrace[stackTraceMethodIndex].getMethodName();

        // remove the post and get at the end of the method name as generated by the openAPI spec
        // do not remove it in general because the methods themselves can contain these terms
        if (methodName.endsWith("Post")) {
            methodName = methodName.substring(0, methodName.length() - 4);
        } else if (methodName.endsWith("Get")) {
            methodName = methodName.substring(0, methodName.length() - 3);
        }

        methodName = methodName.substring("registry".length());

        int end = 0;
        for (int i = 1; i < methodName.length(); i++) {
            if (Character.isUpperCase(methodName.charAt(i))) {
                end = i;
                break;
            }
        }
        final String registryType = methodName.substring(0, end);
        methodName = methodName.substring(end, end + 1).toLowerCase() + methodName.substring(end + 1);

        Object registry;
        try {
            registry = Registries.class.getMethod("get" + registryType + "Registry", boolean.class).invoke(null, true);
        } catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            throw new CouldNotPerformException("Could not resolve registry[" + registryType + "]", e);
        }

        Method method = null;
        for (final Method registryMethod : registry.getClass().getMethods()) {
            if (registryMethod.getName().equals(methodName)) {
                method = registryMethod;
            }
        }

        if (method == null) {
            throw new CouldNotPerformException("Could not resolve method[" + methodName + "] for registry[" + registry.getClass().getSimpleName() + "]");
        }

        if (method.getParameters().length == 0) {
            try {
                return convertReturnValue(method.invoke(registry), returnClass);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new CouldNotPerformException("Could not invoke registry method", e);
            }
        }

        final Object[] parameters = new Object[method.getParameters().length];
        for (int i = 0; i < parameters.length; i++) {
            try {
                Method parameterMethod = parameter.getClass().getMethod("getArg" + i);
                parameters[i] = convertParameter(parameterMethod.invoke(parameter), method.getParameterTypes()[i], method.getGenericParameterTypes()[i]);
            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                throw new CouldNotPerformException("Could not resolve parameter[" + i + "]");
            }
        }

        try {
            return convertReturnValue(method.invoke(registry, parameters), returnClass);
        } catch (IllegalAccessException | InvocationTargetException e) {
            throw new CouldNotPerformException("Could not invoke registry method", e);
        }
    }

    public static Object convertParameter(final Object parameter, final Class<?> parameterClass, final Type genericType) throws CouldNotPerformException {
        if (Message.class.isAssignableFrom(parameterClass)) {
            try {
                Message.Builder newBuilder = (Message.Builder) parameterClass.getMethod("newBuilder").invoke(null);
                JSON_FORMAT.merge(OBJECT_MAPPER.writeValueAsString(parameter), ExtensionRegistry.getEmptyRegistry(), newBuilder);
                return newBuilder.build();
            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | JsonProcessingException | JsonFormat.ParseException e) {
                throw new CouldNotPerformException("Could not map parameterType[" + parameter.getClass().getSimpleName() + "] to message[" + parameterClass.getSimpleName() + "]");
            }
        } else if (ProtocolMessageEnum.class.isAssignableFrom(parameterClass)) {
            try {
                return parameterClass.getMethod("valueOf", String.class).invoke(null, parameter.toString());
            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
                throw new CouldNotPerformException("Could not parse enum[" + parameterClass.getSimpleName() + "] from value[" + parameter + "]");
            }
        } else if (List.class.isAssignableFrom(parameterClass)) {
            if (!List.class.isAssignableFrom(parameter.getClass())) {
                throw new CouldNotPerformException("If parameter class is a list the parameter value also needs to be a list!");
            }

            final List<Object> list = new ArrayList<>();
            for (final Object listObject : ((List) parameter)) {
                list.add(convertParameter(listObject, (Class) ((ParameterizedType) genericType).getActualTypeArguments()[0], null));
            }
            return list;
        } else {
            return parameter;
        }
    }

    public static <T> T convertReturnValue(final Object returnValue, final Class<T> returnClass) throws CouldNotPerformException {
        if (Message.class.isAssignableFrom(returnValue.getClass())) {
            try {

                return OBJECT_MAPPER.readValue(JSON_FORMAT.printToString((Message) returnValue), returnClass);
            } catch (IOException e) {
                throw new CouldNotPerformException("Could not convert value of type[" + returnValue.getClass().getSimpleName() + "] to type[" + returnClass.getSimpleName() + "]");
            }
        } else if (ProtocolMessageEnum.class.isAssignableFrom(returnValue.getClass())) {
            try {
                return OBJECT_MAPPER.readValue(((ProtocolMessageEnum) returnValue).getValueDescriptor().getName(), returnClass);
            } catch (IOException e) {
                throw new CouldNotPerformException("Could not convert enum[" + returnValue.getClass().getSimpleName() + "] to type[" + returnClass.getSimpleName() + "]");
            }
        } else if (List.class.isAssignableFrom(returnClass)) {
            if (!List.class.isAssignableFrom(returnValue.getClass())) {
                throw new CouldNotPerformException("If return class is a list the return value also needs to be a list!");
            }
            final List<Object> list = new ArrayList<>();
            for (Object listObject : ((List) returnValue)) {
                list.add(convertReturnValue(listObject, (Class) ((ParameterizedType) returnClass.getGenericSuperclass()).getActualTypeArguments()[0]));
            }
            return (T) list;
        } else if (Set.class.isAssignableFrom(returnValue.getClass())) {
            if (!List.class.isAssignableFrom(returnClass)) {
                throw new CouldNotPerformException("If returned class is a set the return class needs to be a list!");
            }

            final List<Object> list = new ArrayList<>();
            for (final Object object : ((Set) returnValue)) {
                list.add(convertReturnValue(object, (Class) ((ParameterizedType) returnClass.getGenericSuperclass()).getActualTypeArguments()[0]));
            }
            return (T) list;
        } else {
            return (T) returnValue;
        }
    }
}
