/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.citec.dal.visual.util;

import org.dc.jul.exception.CouldNotPerformException;
import org.dc.jul.exception.NotAvailableException;
import org.dc.jul.exception.VerificationFailedException;
import org.dc.jul.exception.printer.ExceptionPrinter;
import org.dc.jul.exception.printer.LogLevel;
import org.dc.jul.pattern.Observable;
import org.dc.jul.pattern.Observer;
import de.citec.scm.remote.SceneRegistryRemote;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JOptionPane;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.slf4j.LoggerFactory;
import rst.homeautomation.control.action.ActionConfigType.ActionConfig;
import rst.homeautomation.control.scene.SceneConfigType.SceneConfig;
import rst.homeautomation.control.scene.SceneRegistryType;

/**
 *
 * @author <a href="mailto:thuxohl@techfak.uni-bielefeld.com">Tamino Huxohl</a>
 */
public class SceneCreationPanel extends javax.swing.JPanel {

    protected static final org.slf4j.Logger logger = LoggerFactory.getLogger(SceneCreationPanel.class);

    private SceneRegistryRemote sceneRegistryRemote;
    private SceneConfig lastSelected = null;

    /**
     * Creates new form SceneCreationPanel
     *
     */
    public SceneCreationPanel() {
        initComponents();
    }

    public void init() throws CouldNotPerformException, InterruptedException {
        sceneRegistryRemote = new SceneRegistryRemote();
        sceneRegistryRemote.init();
        sceneRegistryRemote.activate();
        initDynamicComponents();
    }

    private void initDynamicComponents() throws CouldNotPerformException {
        sceneRegistryRemote.addObserver(new Observer<SceneRegistryType.SceneRegistry>() {

            @Override
            public void update(Observable<SceneRegistryType.SceneRegistry> source, SceneRegistryType.SceneRegistry data) throws Exception {
                updateDynamicComponents();
            }
        });
        updateDynamicComponents();
    }

    private void updateDynamicComponents() throws CouldNotPerformException {
        ArrayList<SceneConfigHolder> sceneConfigHolderList = new ArrayList<>();
        for (SceneConfig sceneConfig : sceneRegistryRemote.getSceneConfigs()) {
            sceneConfigHolderList.add(new SceneConfigHolder(sceneConfig));
        }
        Collections.sort(sceneConfigHolderList);
        sceneSelectionComboBox.setModel(new DefaultComboBoxModel(sceneConfigHolderList.toArray()));
        if (lastSelected != null) {
            sceneSelectionComboBox.setSelectedItem(new SceneConfigHolder(lastSelected));
        }
    }

    public void updateSceneConfig(List<ActionConfig> actionConfigs) throws CouldNotPerformException {
        SceneConfig.Builder scene = ((SceneConfigHolder) sceneSelectionComboBox.getSelectedItem()).getConfig().toBuilder();
        for (ActionConfig actionConfig : actionConfigs) {
            boolean newAction = true;
            for (ActionConfig.Builder addedActionConfig : scene.getActionConfigBuilderList()) {
                if (actionConfig.getUnitId().equals(addedActionConfig.getUnitId())
                        && actionConfig.getServiceType() == addedActionConfig.getServiceType()
                        && !actionConfig.getServiceAttribute().equals(addedActionConfig.getServiceAttribute())) {
                    addedActionConfig.setServiceAttribute(actionConfig.getServiceAttribute());
                    newAction = false;
                }
            }

            if (newAction) {
                scene.addActionConfig(actionConfig);
            }
        }
        lastSelected = sceneRegistryRemote.updateSceneConfig(scene.build());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        sceneSelectionComboBox = new javax.swing.JComboBox();
        newButton = new javax.swing.JButton();
        deleteButton = new javax.swing.JButton();

        sceneSelectionComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        sceneSelectionComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sceneSelectionComboBoxActionPerformed(evt);
            }
        });

        newButton.setText("New");
        newButton.setMaximumSize(new java.awt.Dimension(81, 25));
        newButton.setMinimumSize(new java.awt.Dimension(81, 25));
        newButton.setPreferredSize(new java.awt.Dimension(81, 25));
        newButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newButtonActionPerformed(evt);
            }
        });

        deleteButton.setText("Delete");
        deleteButton.setMaximumSize(new java.awt.Dimension(80, 25));
        deleteButton.setMinimumSize(new java.awt.Dimension(80, 25));
        deleteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(sceneSelectionComboBox, 0, 295, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(newButton, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(deleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(sceneSelectionComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(newButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(deleteButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void sceneSelectionComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sceneSelectionComboBoxActionPerformed
        lastSelected = ((SceneConfigHolder) sceneSelectionComboBox.getSelectedItem()).getConfig();
        //TODO: update depending components via observer
    }//GEN-LAST:event_sceneSelectionComboBoxActionPerformed

    private void newButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newButtonActionPerformed
        String label = JOptionPane.showInputDialog(this, "Enter scene label");
        try {
            lastSelected = sceneRegistryRemote.registerSceneConfig(SceneConfig.newBuilder().setLabel(label).build());
        } catch (CouldNotPerformException ex) {
            ExceptionPrinter.printHistory(ex, logger, LogLevel.WARN);
        }
    }//GEN-LAST:event_newButtonActionPerformed

    private void deleteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteButtonActionPerformed
        SceneConfig sceneConfig = ((SceneConfigHolder) sceneSelectionComboBox.getSelectedItem()).getConfig();
        if (sceneConfig.hasId() && !sceneConfig.getId().isEmpty()) {
            try {
                sceneRegistryRemote.removeSceneConfig(sceneConfig);
                lastSelected = null;
            } catch (CouldNotPerformException ex) {
                ExceptionPrinter.printHistory(ex, logger, LogLevel.WARN);
            }
        }
    }//GEN-LAST:event_deleteButtonActionPerformed

    private static class SceneConfigHolder implements Comparable<SceneConfigHolder> {

        private final SceneConfig config;

        public SceneConfigHolder(SceneConfig config) {
            this.config = config;
        }

        @Override
        public String toString() {
            if (isNotSpecified()) {
                return "New";
            }
            return config.getLabel();
        }

        public boolean isNotSpecified() {
            return config == null;
        }

        public SceneConfig getConfig() {
            return config;
        }

        public String getSceneId() throws CouldNotPerformException {
            try {
                if (config == null) {
                    throw new NotAvailableException("messageOrBuilder");
                }
                String id = config.getId();
                if (id.isEmpty()) {
                    throw new VerificationFailedException("Detected id is empty!");
                }
                return id;
            } catch (NotAvailableException | VerificationFailedException ex) {
                throw new CouldNotPerformException("Could not detect id.", ex);
            }
        }

        @Override
        public int compareTo(SceneConfigHolder o) {
            return toString().compareTo(o.toString());
        }

        @Override
        public boolean equals(final Object obj) {
            if (obj instanceof SceneConfigHolder) {
                final SceneConfigHolder other = (SceneConfigHolder) obj;
                try {
                    return new EqualsBuilder()
                            .append(getSceneId(), other.getSceneId())
                            .isEquals();
                } catch (CouldNotPerformException ex) {
                    return new EqualsBuilder()
                            .append(getConfig(), other.getConfig())
                            .isEquals();
                }
            } else {
                return false;
            }
        }

        @Override
        public int hashCode() {
            try {
                return new HashCodeBuilder()
                        .append(getSceneId())
                        .toHashCode();
            } catch (CouldNotPerformException ex) {
                return new HashCodeBuilder()
                        .append(config)
                        .toHashCode();
            }
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton deleteButton;
    private javax.swing.JButton newButton;
    private javax.swing.JComboBox sceneSelectionComboBox;
    // End of variables declaration//GEN-END:variables
}
